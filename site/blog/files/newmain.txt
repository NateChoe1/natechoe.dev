//This is still old code released under the GNU General Public License v3
//This code is slightly newer.
int *pending = calloc(processes - 1, sizeof(int));
int (*notify)[2] = malloc(sizeof(int[2]) * (processes - 1));
//instead of a schedule, we have several pipes
pthread_t *threads = malloc(sizeof(pthread_t) * (processes - 1));
if (threads == NULL)
        exit(EXIT_FAILURE);

for (int i = 0; i < processes - 1; i++) {
        if (pipe(notify[i]))
                exit(EXIT_FAILURE);
        //create the pipes for the runner threads
        RunnerArgs *args = malloc(sizeof(RunnerArgs));
        if (args == NULL)
                exit(EXIT_FAILURE);
        args->site = site;
        args->pending = pending;
        args->notify = notify[i][0];
        args->id = i;
        pthread_create(threads + i, NULL,
                       (void*(*)(void*)) runServer, args);
}
//create the runner threads

for (;;) {
        fsync(fd);
        //Still have no clue why this works, it's not in the new code.
        int newfd = accept(fd, (struct sockaddr *) &addr,
                               &addrlen);
        //accept connections (blocking)
        if (newfd < 0)
                exit(EXIT_FAILURE);
        int flags = fcntl(newfd, F_GETFL);
        if (fcntl(newfd, F_SETFL, flags | O_NONBLOCK))
                exit(EXIT_FAILURE);
        //make the connection nonblocking
        int lowestThread = 0;
        int lowestCount = pending[0];
        for (int i = 1; i < processes - 1; i++) {
                if (pending[i] < lowestCount) {
                        lowestThread = i;
                        lowestCount = pending[i];
                }
        }
        //get the least busiest thread
        if (write(notify[lowestThread][1], &newfd, sizeof(newfd))
                  < sizeof(newfd))
                exit(EXIT_FAILURE);
        //send that thread the new connection
}
