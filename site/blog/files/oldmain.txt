//NOTE: This is old code, not used anymore. It is also released under the
//GNU General Public License v3.

int *pending = calloc(processes - 1, sizeof(int));
//Each runner thread has an id, and pending[id] shows the number of connections
//that thread is handling

int *schedule = malloc(2 * sizeof(int));
if (schedule == NULL)
        exit(EXIT_FAILURE);
schedule[0] = -1;
//schedule[0] is the thread that should take the next connection
//schedule[1] is the file descriptor of the next connection

pthread_t *threads = malloc(sizeof(pthread_t) * (processes - 1));
if (threads == NULL)
        exit(EXIT_FAILURE);
for (int i = 0; i < processes - 1; i++) {
        RunnerArgs *args = malloc(sizeof(RunnerArgs));
        if (args == NULL)
                exit(EXIT_FAILURE);
        args->site = site;
        args->pending = pending;
        args->schedule = schedule;
        args->id = i;
        pthread_create(threads + i, NULL,
                       (void*(*)(void*)) runServer, args);
}
//create the runner threads

for (;;) {
        fsync(fd);
        //I have no idea how this works, but for some reason the server broke
        //when I didn't have this
        if (schedule[0] == -1) {
                int newfd = accept(fd, (struct sockaddr *) &addr,
                                       &addrlen);
                //accept a connection
                if (newfd < 0)
                        exit(EXIT_FAILURE);
                int flags = fcntl(newfd, F_GETFL);
                if (fcntl(newfd, F_SETFL, flags | O_NONBLOCK))
                        exit(EXIT_FAILURE);
                //make it nonblocking
                int lowestThread = 0;
                int lowestCount = pending[0];
                for (int i = 1; i < processes - 1; i++) {
                        if (pending[i] < lowestCount) {
                                lowestThread = i;
                                lowestCount = pending[i];
                        }
                }
                //get the least busy thread
                schedule[1] = newfd;
                schedule[0] = lowestThread;
                //give that thread the connection
        }
}

